"""
Привет!

Этот код — попытка реализации эндпоинта для работы с данными клиники.
Известные проблемы:
  - Отсутствует categoryId в записях.
  - Эндпоинт для проверки свободных окон (free slots) не работает.

Будущему разработчику: в коде реализована базовая логика загрузки данных, генерации эмбеддингов (с использованием SentenceTransformer, BM25 и FAISS) и функция вызова OpenAI (function calling).еспли будешь разбираться так же с нуля,первым делом получи parent_id(category_id),думаю,что фикс эндроинта уже будет если будут вопросы по коду - пиши tg - vozzynebot,
"""

import aiohttp
import asyncio
import aiofiles
import json
import uvicorn
import logging
import time
import os
import numpy as np
import re
import pickle
from pathlib import Path
from fastapi import FastAPI, HTTPException, Form, UploadFile, File
from sentence_transformers import SentenceTransformer, CrossEncoder
from rank_bm25 import BM25Okapi
# from voicerecognise import recognize_audio_with_sdk  # Пока не используем
# from yandex_cloud_ml_sdk import YCloudML  # Пока не используем
from typing import Dict, List, Optional
import faiss
import requests
import openai

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

# Глобальные параметры
GLOBAL_TENANT_ID = "medyumed.2023-04-24"  # РЕАЛЬНЫЙ ID тенанта!
GLOBAL_LANG_ID = "ru"  # Используем нужный язык
BASE_DIR = "base"
EMBEDDINGS_DIR = "embeddings_data"
os.makedirs(BASE_DIR, exist_ok=True)
os.makedirs(EMBEDDINGS_DIR, exist_ok=True)
API_URL = "https://dev.back.matrixcrm.ru/api/v1/AI/servicesByFilters"
API_FREE_TIMES_URL = "https://dev.back.matrixcrm.ru/api/v1/AI/getFreeTimesOfEmployeeByChoosenServices"
API_ADD_RECORD_URL = "https://dev.back.matrixcrm.ru/api/v1/AI/addRecord"

OPENAI_API_KEY = "YOUR_OPENAI_API_KEY"  # Замените на свой реальный ключ OpenAI
openai.api_key = OPENAI_API_KEY

logger.info("Загрузка моделей...")
search_model = SentenceTransformer("sentence-transformers/paraphrase-multilingual-mpnet-base-v2")
cross_encoder = CrossEncoder('cross-encoder/ms-marco-MiniLM-L-6-v2')
logger.info("Модели успешно загружены.")

conversation_history: Dict[str, Dict] = {}
app = FastAPI()

def get_tenant_path(tenant_id: str) -> Path:
    """Возвращает папку для тенанта (создает, если не существует)."""
    tenant_path = Path(EMBEDDINGS_DIR) / tenant_id
    tenant_path.mkdir(parents=True, exist_ok=True)
    return tenant_path

def normalize_text(text: str) -> str:
    """Нормализует текст: приводит к нижнему регистру, убирает лишние символы."""
    text = text.lower().strip()
    return re.sub(r"[^\w\s\d]", "", text)

def tokenize_text(text: str) -> List[str]:
    """Разбивает текст на токены, исключая стоп-слова."""
    stopwords = {"и", "в", "на", "с", "по", "для", "как", "что", "это", "но",
                 "а", "или", "у", "о", "же", "за", "к", "из", "от", "так", "то", "все"}
    return [word for word in text.split() if word not in stopwords]

def extract_text_fields(record: dict) -> str:
    """Формирует читаемое представление записи."""
    filial = record.get("filialName", "Филиал не указан")
    category = record.get("categoryName", "Категория не указана")
    service = record.get("serviceName", "Услуга не указана")
    service_desc = record.get("serviceDescription", "Описание не указано")
    price = record.get("price", "Цена не указана")
    specialist = record.get("employeeFullName", "Специалист не указан")
    spec_desc = record.get("employeeDescription", "Описание не указано")
    text = (
        f"Филиал: {filial}\n"
        f"Категория: {category}\n"
        f"Услуга: {service}\n"
        f"Описание услуги: {service_desc}\n"
        f"Цена: {price}\n"
        f"Специалист: {specialist}\n"
        f"Описание специалиста: {spec_desc}"
    )
    return normalize_text(text)

def build_hidden_context(record: dict) -> str:
    """Создает скрытый блок с ID (filialId, categoryId, serviceId, employeeId)."""
    filial_id = record.get("filialId") or "Не указан"
    category_id = record.get("categoryId") or "Не указан"
    service_id = record.get("serviceId") or "Не указан"
    employee_id = record.get("employeeId") or "Не указан"
    return f"[HIDDEN_START] filialid:{filial_id}; categoryid:{category_id}; serviceid:{service_id}; employeeid:{employee_id} [HIDDEN_END]"

def build_full_context(record: dict) -> str:
    """Объединяет публичное представление и скрытый блок с ID."""
    return extract_text_fields(record) + "\n" + build_hidden_context(record)

async def load_json_data(tenant_id: str) -> List[dict]:
    """Загружает данные из файла и возвращает список записей."""
    file_path = os.path.join(BASE_DIR, f"{tenant_id}.json")
    if not os.path.exists(file_path):
        raise HTTPException(status_code=404, detail=f"Файл для tenant_id={tenant_id} не найден.")
    async with aiofiles.open(file_path, "r", encoding="utf-8") as f:
        data = json.loads(await f.read())
    records = []
    branches = data.get("data", {}).get("branches", [])
    for branch in branches:
        filial_name = branch.get("name", "Филиал не указан")
        filial_id = branch.get("id") or branch.get("ID") or "Не указан"
        logger.info(f"Branch: {filial_name}, ID: {filial_id}")
        categories = branch.get("categories", [])
        for category in categories:
            category_name = category.get("name", "Категория не указана")
            category_id = category.get("id") or category.get("ID") or "Не указан"
            logger.info(f"  Category: {category_name}, ID: {category_id}")
            services = category.get("services", [])
            for service in services:
                service_name = service.get("name", "Услуга не указана")
                price = service.get("price", "Цена не указана")
                service_description = service.get("description", "")
                service_id = service.get("id") or service.get("ID") or "Не указан"
                logger.info(f"    Service: {service_name}, ID: {service_id}")
                employees = service.get("employees", [])
                if employees:
                    for emp in employees:
                        employee_full_name = emp.get("full_name", "Специалист не указан")
                        employee_description = emp.get("description", "Описание не указано")
                        employee_id = emp.get("id") or emp.get("ID") or "Не указан"
                        logger.info(f"      Employee: {employee_full_name}, ID: {employee_id}")
                        record = {
                            "filialName": filial_name,
                            "filialId": filial_id,
                            "categoryName": category_name,
                            "categoryId": category_id,
                            "serviceName": service_name,
                            "serviceDescription": service_description,
                            "price": price,
                            "employeeFullName": employee_full_name,
                            "employeeDescription": employee_description,
                            "employeeId": employee_id,
                            "serviceId": service_id
                        }
                        records.append(record)
                        print("ДОБАВЛЕННАЯ ЗАПИСЬ:", record)
                else:
                    record = {
                        "filialName": filial_name,
                        "filialId": filial_id,
                        "categoryName": category_name,
                        "categoryId": category_id,
                        "serviceName": service_name,
                        "serviceDescription": service_description,
                        "price": price,
                        "employeeFullName": "Специалист не указан",
                        "employeeDescription": "Описание не указано",
                        "employeeId": "Не указан",
                        "serviceId": service_id
                    }
                    records.append(record)
                    print("ДОБАВЛЕННАЯ ЗАПИСЬ (без специалиста):", record)
    return records

async def prepare_data(tenant_id: str):
    """Готовит данные: загружает JSON, строит эмбеддинги, BM25 и FAISS-индекс."""
    tenant_path = get_tenant_path(tenant_id)
    data_file = tenant_path / "data.json"
    embeddings_file = tenant_path / "embeddings.npy"
    bm25_file = tenant_path / "bm25.pkl"
    faiss_index_file = tenant_path / "faiss_index.index"

    if all([f.exists() for f in [data_file, embeddings_file, bm25_file, faiss_index_file]]):
        file_age = time.time() - os.path.getmtime(data_file)
        if file_age < 2_592_000:  # 30 дней
            async with aiofiles.open(data_file, "r", encoding="utf-8") as f:
                data = json.loads(await f.read())
            embeddings = np.load(embeddings_file)
            with open(bm25_file, "rb") as f:
                bm25 = pickle.load(f)
            index = faiss.read_index(str(faiss_index_file))
            return data, embeddings, bm25, index

    records = await load_json_data(tenant_id)
    documents = [build_full_context(record) for record in records]

    loop = asyncio.get_event_loop()
    embeddings, bm25 = await asyncio.gather(
        loop.run_in_executor(None, lambda: search_model.encode(documents, convert_to_tensor=True).cpu().numpy()),
        loop.run_in_executor(None, lambda: BM25Okapi([tokenize_text(doc) for doc in documents]))
    )

    dimension = embeddings.shape[1]
    index = faiss.IndexFlatL2(dimension)
    index.add(embeddings)
    faiss.write_index(index, str(faiss_index_file))

    async with aiofiles.open(data_file, "w", encoding="utf-8") as f:
        await f.write(json.dumps({
            "records": records,
            "raw_texts": documents,
            "timestamp": time.time()
        }, ensure_ascii=False, indent=4))

    np.save(embeddings_file, embeddings)
    with open(bm25_file, "wb") as f:
        pickle.dump(bm25, f)

    return {"records": records, "raw_texts": documents}, embeddings, bm25, index

async def update_json_file(mydtoken: str, tenant_id: str):
    """Обновляет JSON-файл с данными (до 50 страниц)."""
    tenant_path = get_tenant_path(tenant_id)
    file_path = os.path.join(BASE_DIR, f"{tenant_id}.json")
    if os.path.exists(file_path):
        file_age = time.time() - os.path.getmtime(file_path)
        if file_age < 2_592_000:
            logger.info(f"Файл {file_path} актуален, пропускаем обновление.")
            return

    for f in tenant_path.glob("*"):
        try:
            os.remove(f)
        except Exception as e:
            logger.error(f"Ошибка удаления файла {f}: {e}")

    try:
        async with aiohttp.ClientSession() as session:
            headers = {"Authorization": f"Bearer {mydtoken}"}
            params = {"tenantId": tenant_id, "page": 1}
            all_data = []
            max_pages = 50
            while True:
                if params["page"] > max_pages:
                    logger.info(f"Достигнут лимит {max_pages} страниц, завершаем загрузку.")
                    break
                async with session.get(API_URL, headers=headers, params=params) as response:
                    response.raise_for_status()
                    data = await response.json()
                    branches = data.get("data", {}).get("branches", [])
                    if not branches:
                        logger.info(f"Страница {params['page']} пустая, завершаем загрузку.")
                        break
                    all_data.extend(branches)
                    logger.info(f"Получено {len(branches)} записей с страницы {params['page']}.")
                    params["page"] += 1

            logger.info(f"Общее число полученных филиалов: {len(all_data)}")
            async with aiofiles.open(file_path, "w", encoding="utf-8") as json_file:
                await json_file.write(json.dumps(
                    {"code": data.get("code", 200), "data": {"branches": all_data}},
                    ensure_ascii=False,
                    indent=4
                ))
    except Exception as e:
        logger.error(f"Ошибка при обновлении файла: {str(e)}")
        raise HTTPException(status_code=500, detail="Ошибка обновления данных.")

async def rerank_with_cross_encoder(query: str, candidates: List[int], raw_texts: List[str]) -> List[int]:
    """Переранжирует топ-10 кандидатов с помощью кросс-энкодера."""
    cross_inp = [(query, raw_texts[idx]) for idx in candidates]
    loop = asyncio.get_event_loop()
    cross_scores = await loop.run_in_executor(None, lambda: cross_encoder.predict(cross_inp))
    sorted_indices = np.argsort(cross_scores)[::-1].tolist()
    return [candidates[i] for i in sorted_indices]

async def get_free_times(employeeId: str, serviceId: List[str], dateTime: str, tenantId: str, filialId: str, langId: str, mydtoken: str) -> dict:
    """Вызывает API для получения свободного времени сотрудника."""
    logger.info(f"get_free_times: employeeId={employeeId}, serviceId={serviceId}, dateTime={dateTime}")
    url = API_FREE_TIMES_URL
    headers = {"Content-Type": "application/json", "Authorization": f"Bearer {mydtoken}"}
    data = {
        "employeeId": employeeId,
        "serviceId": serviceId,
        "dateTime": dateTime,
        "tenantId": tenantId,
        "filialId": filialId,
        "langId": langId
    }
    try:
        response = requests.post(url, headers=headers, json=data)
        response.raise_for_status()
        result = response.json()
        logger.info(f"Received response from API: {result}")
        return result
    except requests.exceptions.RequestException as e:
        logger.error(f"Ошибка при запросе к API getFreeTimes: {e}")
        return {"availableSlots": []}

async def get_free_times_proxy(employeeId: str, serviceId: str, date: str, time_str: str, tenantId: str, filialId: str, langId: str, mydtoken: str) -> dict:
    """Обертка для get_free_times для OpenAI function calling."""
    date_time = f"{date}T{time_str}:00"
    return await get_free_times(employeeId, [serviceId], date_time, tenantId, filialId, langId, mydtoken)

async def create_appointment(employeeId: str, serviceId: str, filialId: str, dateOfRecord: str, startTime: str,
                             tenantId: str, user_name: str, phone: str, mydtoken: str) -> dict:
    """Вызывает API для создания записи на прием (заглушка)."""
    logger.info(f"create_appointment: employeeId={employeeId}, serviceId={serviceId}, filialId={filialId}")
    url = API_ADD_RECORD_URL  # Заменить на реальный URL
    headers = {"Content-Type": "application/json", "Authorization": f"Bearer {mydtoken}"}
    data = {
        "langId": GLOBAL_LANG_ID,
        "clientPhoneNumber": phone,
        "services": [{
            "rowNumber": 0,
            "parentId": "string",
            "serviceId": serviceId,
            "serviceName": "string",
            "countService": 1,
            "discount": 0,
            "price": 0,
            "salePrice": 0,
            "complexServiceId": "string",
            "durationService": 0
        }],
        "filialId": filialId,
        "dateOfRecord": dateOfRecord,
        "startTime": startTime,
        "endTime": "string",
        "durationOfTime": 0,
        "colorCodeRecord": "string",
        "toEmployeeId": employeeId,
        "totalPrice": 0
    }
    print("Сформированный запрос к API create_appointment:")
    print(json.dumps(data, indent=2, ensure_ascii=False))
    print("Заголовки:", headers)
    return {"success": True, "message": "Запись создана (заглушка)"}

functions = [
    {
        "name": "get_free_times_proxy",
        "description": "Получить свободное время сотрудника для записи на услугу.",
        "parameters": {
            "type": "object",
            "properties": {
                "employeeId": {"type": "string", "description": "ID сотрудника."},
                "serviceId": {"type": "string", "description": "ID услуги."},
                "date": {"type": "string", "description": "Дата в формате YYYY-MM-DD."},
                "time": {"type": "string", "description": "Время в формате HH:mm."},
                "filialId": {"type": "string", "description": "ID филиала."}
            },
            "required": ["employeeId", "serviceId", "date", "time", "filialId"]
        }
    },
    {
        "name": "create_appointment",
        "description": "Записать пользователя на прием.",
        "parameters": {
            "type": "object",
            "properties": {
                "employeeId": {"type": "string", "description": "ID сотрудника."},
                "serviceId": {"type": "string", "description": "ID услуги."},
                "filialId": {"type": "string", "description": "ID филиала."},
                "dateOfRecord": {"type": "string", "format": "date", "description": "Дата записи в формате YYYY-MM-DD."},
                "startTime": {"type": "string", "format": "time", "description": "Время начала записи в формате HH:mm."},
                "user_name": {"type": "string", "description": "Имя пользователя."},
                "phone": {"type": "string", "description": "Номер телефона пользователя."}
            },
            "required": ["employeeId", "serviceId", "filialId", "dateOfRecord", "startTime", "user_name", "phone"]
        }
    }
]

async def generate_response_with_openai(messages: List[Dict], available_functions: Dict) -> str:
    """Генерирует ответ с использованием OpenAI function calling."""
    try:
        client = openai.OpenAI(api_key=OPENAI_API_KEY)  # Создаем клиент API
        response = client.chat.completions.create(
            model="gpt-3.5-turbo-0613",  # Обновленная модель
            messages=messages,
            tools=functions,
            tool_choice="auto"
        )
        response_message = response.choices[0].message

        if response_message.tool_calls:
            tool_call = response_message.tool_calls[0]
            function_name = tool_call.function.name
            function_arguments = json.loads(tool_call.function.arguments)

            if function_name == "get_free_times_proxy":
                function_response = await get_free_times_proxy(
                    **function_arguments,
                    tenantId=GLOBAL_TENANT_ID,
                    langId=GLOBAL_LANG_ID,
                    mydtoken="YOUR_MYD_TOKEN"
                )
            elif function_name == "create_appointment":
                function_response = await create_appointment(
                    **function_arguments,
                    tenantId=GLOBAL_TENANT_ID,
                    langId=GLOBAL_LANG_ID,
                    mydtoken="YOUR_MYD_TOKEN"
                )
            else:
                return "Извините, я не знаю такую функцию."

            messages.append(response_message)
            messages.append({
                "role": "function",
                "name": function_name,
                "content": json.dumps(function_response, ensure_ascii=False)
            })

            second_response = client.chat.completions.create(
                model="gpt-3.5-turbo-0613",
                messages=messages,
            )
            return second_response.choices[0].message.content.strip()
        else:
            return response_message.content.strip()
    except Exception as e:
        logger.error(f"Ошибка OpenAI API: {str(e)}")
        return "Извините, произошла ошибка при генерации ответа."

@app.post("/ask")
async def ask_assistant(
    user_id: str = Form(...),
    question: Optional[str] = Form(None),
    mydtoken: str = Form(...),
    tenant_id: str = Form(...),
    file: UploadFile = File(None),
    user_name: Optional[str] = Form(None),
    phone: Optional[str] = Form(None)
):
    try:
        input_text = question
        if not input_text:
            raise HTTPException(status_code=400, detail="Необходимо передать текст.")

        force_update = False
        if force_update or not (get_tenant_path(tenant_id) / "data.json").exists():
            await update_json_file(mydtoken, tenant_id)

        data_dict, embeddings, bm25, faiss_index = await prepare_data(tenant_id)
        normalized_question = normalize_text(input_text)
        tokenized_query = tokenize_text(normalized_question)
        bm25_scores = bm25.get_scores(tokenized_query)
        top_bm25_indices = np.argsort(bm25_scores)[::-1][:50].tolist()

        loop = asyncio.get_event_loop()
        query_embedding = await loop.run_in_executor(
            None,
            lambda: search_model.encode(normalized_question, convert_to_tensor=True).cpu().numpy()
        )

        D, I = faiss_index.search(query_embedding.reshape(1, -1), 50)
        DISTANCE_THRESHOLD = 0.6
        filtered_faiss = [idx for idx, dist in zip(I[0].tolist(), D[0].tolist()) if dist < DISTANCE_THRESHOLD]
        if not filtered_faiss:
            filtered_faiss = I[0].tolist()
        top_faiss_indices = filtered_faiss

        combined_indices = list(set(top_bm25_indices + top_faiss_indices))[:50]
        top_10_indices = await rerank_with_cross_encoder(
            query=normalized_question,
            candidates=combined_indices[:10],
            raw_texts=data_dict["raw_texts"]
        )

        context = "\n".join([
            f"{i+1}. {extract_text_fields(data_dict['records'][idx])}"
            for i, idx in enumerate(top_10_indices)
        ])
        full_context = "\n".join([
            build_full_context(data_dict['records'][idx])
            for idx in top_10_indices
        ])

        top_records = [data_dict['records'][idx] for idx in top_10_indices]

        messages = [
            {"role": "system", "content": "Ты – администратор клиники MED YU MED. Твоя задача – помогать пользователям находить информацию о специалистах, услугах, филиалах и ценах, а также записывать их на прием."},
            {"role": "system", "content": f"Контекст:\n{context}"},
            {"role": "user", "content": input_text}
        ]

        response = await generate_response_with_openai(messages, available_functions={
            "get_free_times_proxy": get_free_times_proxy,
            "create_appointment": create_appointment
        })

        if isinstance(response, dict) and response.get("function_call"):
            function_name = response["function_call"]["name"]
            arguments = json.loads(response["function_call"]["arguments"])

            if function_name == "get_free_times_proxy":
                matching_record = None
                for record in top_records:
                    if (record.get('employeeId') == arguments.get('employeeId') and
                        record.get('serviceId') == arguments.get('serviceId') and
                        record.get('filialId') == arguments.get('filialId')):
                        matching_record = record
                        break
                if matching_record:
                    service_id = matching_record['serviceId']
                    try:
                        free_times_result = await get_free_times_proxy(
                            employeeId=arguments['employeeId'],
                            serviceId=service_id,
                            date=arguments['date'],
                            time=arguments['time'],
                            filialId=arguments['filialId'],
                            tenantId=GLOBAL_TENANT_ID,
                            langId=GLOBAL_LANG_ID,
                            mydtoken=mydtoken
                        )
                        response_text = f"Свободные слоты: {json.dumps(free_times_result, ensure_ascii=False)}"
                    except Exception as e:
                        response_text = f"Произошла ошибка при получении свободного времени: {e}"
                else:
                    response_text = "Извините, не удалось найти подходящую услугу и специалиста."
            elif function_name == "create_appointment":
                try:
                    appointment_result = await create_appointment(
                        employeeId=arguments['employeeId'],
                        serviceId=arguments['serviceId'],
                        filialId=arguments['filialId'],
                        dateOfRecord=arguments['date'],
                        startTime=arguments['time'],
                        user_name=user_name,
                        phone=phone,
                        tenantId=GLOBAL_TENANT_ID,
                        langId=GLOBAL_LANG_ID,
                        mydtoken=mydtoken
                    )
                    response_text = appointment_result.get("message", "Запись создана (заглушка).")
                except Exception as e:
                    response_text = f"Произошла ошибка при создании записи: {e}"
            else:
                response_text = "Извините, я не знаю такую функцию."
        else:
            response_text = response

        return {"response": response_text}
    except Exception as e:
        logger.error(f"Ошибка обработки запроса: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Ошибка обработки запроса: {str(e)}")

if __name__ == "__main__":
    logger.info("Запуск сервера на порту 8001...")
    uvicorn.run(app, host="0.0.0.0", port=8001)
