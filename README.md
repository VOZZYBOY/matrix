# Med YU Med - Виртуальный Ассистент (LangChain + DeepSeek + RAG)

## 1. Обзор

Виртуальный ассистент Med YU Med - это AI-помощник, построенный с использованием фреймворка **LangChain**. Он предназначен для ответов на вопросы пользователей об услугах, ценах, специалистах и филиалах клиники Med YU Med, поддерживая естественный диалог.

Ключевые технологии:
- **FastAPI**: Веб-сервер для предоставления API и простого веб-интерфейса.
- **LangChain**: Основной фреймворк для оркестрации языковой модели, RAG и инструментов.
- **DeepSeek**: Используется как основная языковая модель для генерации ответов, выбора действий и вызова инструментов.
- **GigaChat Embeddings**: Модель для создания векторных представлений (эмбеддингов) данных клиники.
- **ChromaDB**: Локальная векторная база данных для семантического поиска (dense retrieval).
- **BM25 (опционально, рекомендуется)**: Алгоритм поиска по ключевым словам (sparse retrieval) для улучшения нахождения точных совпадений.
- **EnsembleRetriever (опционально, рекомендуется)**: Комбинирует ChromaDB и BM25 для **гибридного поиска** в RAG (Retrieval-Augmented Generation).
- **LangChain Tools (Function Calling)**: Набор Python-функций, которые модель может вызывать для получения конкретной информации из данных клиники.

## 2. Архитектура

Приложение состоит из следующих основных модулей:

1.  **`app.py`**: FastAPI приложение, предоставляющее HTTP API эндпоинты, обслуживающее статические файлы и HTML-шаблон для веб-интерфейса.
2.  **`matrixai.py`**: Основной модуль логики ассистента. Он инициализирует LLM (DeepSeek), определяет и привязывает инструменты (function calling), управляет историей диалогов и координирует обработку запросов, включая предварительный анализ для RAG.
3.  **`rag_setup.py`**: Модуль, отвечающий за настройку RAG:
    *   Загружает и обрабатывает данные клиники (`base/cleaned_data.json`).
    *   Инициализирует модель эмбеддингов (`GigaChat Embeddings`).
    *   Создает или загружает векторную базу **ChromaDB**.
    *   (Опционально) Настраивает **BM25Retriever**.
    *   (Опционально) Создает **EnsembleRetriever** для гибридного поиска.
    *   Предоставляет готовый ретривер для `matrixai.py`.
    *   Содержит вспомогательные функции для RAG (`add_instruction_to_query`, `format_docs`).
4.  **`clinic_functions.py`**: Модуль с классами, реализующими бизнес-логику для инструментов (реальный поиск по данным клиники).
5.  **`base/cleaned_data.json`**: JSON-файл с исходными данными клиники.
6.  **`chroma_db_clinic_giga/`**: Директория для персистентного хранения векторной базы ChromaDB.

## 3. Ключевые компоненты и флоу (`matrixai.py` + `rag_setup.py`)

- **Инициализация**: При старте `matrixai.py`:
    - Загружаются учетные данные (DeepSeek API Key, GigaChat Credentials).
    - Инициализируется чат-модель `ChatDeepSeek`.
    - Вызывается `rag_setup.initialize_rag()` для:
        - Загрузки данных из `cleaned_data.json`.
        - Инициализации `GigaChatEmbeddings`.
        - Настройки RAG (ChromaDB, опционально BM25 и EnsembleRetriever).
        - Получения готового `retriever` и данных `clinic_data`.
    - Данные `clinic_data` передаются в `clinic_functions` через `set_clinic_data`.
    - Определяются и привязываются инструменты (`@tool`) к модели `ChatDeepSeek`.
    - Настраивается цепочка `chain_with_history`.
- **Обработка запроса (`run_agent_like_chain`)**:
    1.  **Шаг 1: Улучшение RAG-запроса (CoT):** Выполняется первый вызов `ChatDeepSeek` для анализа запроса пользователя в контексте истории. Генерируется оптимальный поисковый запрос (`effective_rag_query`) специально для RAG, особенно для разрешения ссылок типа "расскажи о 7".
    2.  **Шаг 2: RAG-поиск:** Вызывается `retriever.invoke()` (который может быть Chroma, BM25 или Ensemble) с `effective_rag_query` (предварительно добавив инструкцию через `rag_setup.add_instruction_to_query`). Получается `rag_context`.
    3.  **Шаг 3: Основной вызов LLM:** Формируется промпт для `ChatDeepSeek`, включающий системную инструкцию, историю, **оригинальный** запрос пользователя и полученный `rag_context`.
    4.  **Шаг 4: Принятие решения:** Основная LLM решает, что делать:
        *   **Вызвать инструмент:** Если запрос требует конкретных данных (цена, список и т.д.), LLM генерирует `tool_calls`.
        *   **Ответить напрямую:** Если это описание (используя `rag_context`), ответ из памяти или простой ответ.
    5.  **Шаг 5 (Если вызван инструмент):** Соответствующая функция из `clinic_functions.py` выполняется. Ее результат передается обратно LLM (второй основной вызов) для формулирования финального ответа.
    6.  **Шаг 6: Ответ пользователю:** Финальный текстовый ответ возвращается.
- **Управление историей (`RunnableWithMessageHistory`, `get_session_history`, `chat_memory`)**:
    - История хранится **в памяти** (`dict`).
    - `RunnableWithMessageHistory` автоматически управляет историей.
    - **Внимание**: История **теряется при перезапуске** приложения. Для персистентной истории требуется внешнее хранилище (например, Redis, БД).
- **Инструменты (Function Calling)**: Модель DeepSeek обучена использовать следующие инструменты:

    | Инструмент (`@tool` name)                         | Описание                                                                    | Обязательные параметры Pydantic | Класс в `clinic_functions.py`                     |
    | :------------------------------------------------ | :-------------------------------------------------------------------------- | :------------------------------ | :------------------------------------------------ |
    | `find_employees`                                | Поиск сотрудников по ФИО, услуге ИЛИ филиалу.                               | Нет                             | `FindEmployees`                                 |
    | `get_service_price`                             | Цена КОНКРЕТНОЙ услуги (опц. в филиале).                                  | `service_name`                  | `GetServicePrice`                               |
    | `list_filials`                                  | Список ВСЕХ филиалов.                                                       | Нет                             | `ListFilials`                                   |
    | `get_employee_services`                         | Список услуг КОНКРЕТНОГО сотрудника.                                      | `employee_name`                 | `GetEmployeeServices`                           |
    | `check_service_in_filial`                       | Проверка наличия КОНКРЕТНОЙ услуги в КОНКРЕТНОМ филиале.                     | `service_name`, `filial_name`   | `CheckServiceInFilial`                          |
    | `compare_service_price_in_filials`              | Сравнение цены КОНКРЕТНОЙ услуги в НЕСКОЛЬКИХ (≥2) филиалах.                | `service_name`, `filial_names`  | `CompareServicePriceInFilials`                  |
    | `find_service_locations`                        | Поиск ВСЕХ филиалов для КОНКРЕТНОЙ услуги.                                  | `service_name`                  | `FindServiceLocations`                          |
    | `find_specialists_by_service_or_category_and_filial` | Поиск СПЕЦИАЛИСТОВ по УСЛУГЕ/КАТЕГОРИИ в КОНКРЕТНОМ филиале.               | `query_term`, `filial_name`     | `FindSpecialistsByServiceOrCategoryAndFilial` |
    | `list_services_in_category`                     | Список КОНКРЕТНЫХ услуг в указанной КАТЕГОРИИ.                             | `category_name`                 | `ListServicesInCategory`                          |
    | `list_services_in_filial`                       | Список ВСЕХ УНИКАЛЬНЫХ услуг в КОНКРЕТНОМ филиале.                         | `filial_name`                   | `ListServicesInFilial`                          |
    | `find_services_in_price_range`                  | Поиск услуг в ЗАДАННОМ ЦЕНОВОМ ДИАПАЗОНЕ (опц. фильтры).                   | `min_price`, `max_price`        | `FindServicesInPriceRange`                      |
    | `list_all_categories`                           | Список ВСЕХ УНИКАЛЬНЫХ категорий услуг.                                     | Нет                             | `ListAllCategories`                             |
    | `list_employee_filials`                         | **(Новый!)** Список ВСЕХ филиалов КОНКРЕТНОГО сотрудника.                    | `employee_name`                 | `ListEmployeeFilials`                           |

## 4. Настройка и Запуск

### Требования
- Python 3.10+ (рекомендуется для последних версий LangChain)
- Docker (опционально)
- API ключи DeepSeek и GigaChat
- Зависимости (см. `requirements.txt`)

### Установка зависимостей
```bash
# Создание и активация виртуального окружения
# python -m venv venv
# source venv/bin/activate # Linux/macOS
# venv\Scripts\activate # Windows

pip install -r requirements.txt
# Если используете BM25, установите:
pip install rank_bm25
\activate # Windows

pip install -r requirements.txt
# Если используете BM25, установите:
pip install rank_bm25

### Конфигурация
1.  **API Ключи**:
    - Установите переменные окружения `DEEPSEEK_API_KEY` и `GIGACHAT_CREDENTIALS`.
    - Или пропишите их в качестве значений по умолчанию в `matrixai.py` (менее безопасно).
2.  **Данные клиники**: Убедитесь, что файл `base/cleaned_data.json` существует и содержит актуальные данные.
3.  **Константы в `matrixai.py`**: При необходимости можно изменить пути к файлу данных (`JSON_DATA_PATH`), директории ChromaDB (`CHROMA_PERSIST_DIR`), или названия используемых моделей (`DEEPSEEK_CHAT_MODEL`, `GIGA_EMBEDDING_MODEL`).

### Запуск

#### Локально (для разработки)
```bash
# Запуск через app.py (uvicorn встроен)
python app.py

# Или напрямую через uvicorn с автоперезагрузкой
uvicorn app:app --host 0.0.0.0 --port 8001 --reload
```
Приложение будет доступно по адресу `http://localhost:8001`.

#### Через Docker
1.  **Сборка образа:**
    ```bash
    docker build -t matrixai-app .
    ```
2.  **Запуск контейнера:**
    ```bash
    # Убедитесь, что передаете API ключи как переменные окружения
    docker run -d \
      -p 8001:8001 \
      -e DEEPSEEK_API_KEY="ВАШ_КЛЮЧ_DEEPSEEK" \
      -e GIGACHAT_CREDENTIALS="ВАШИ_ДАННЫЕ_GIGACHAT" \
      --name matrixai-instance \
      matrixai-app
    ```
    Приложение будет доступно по адресу `http://localhost:8001` (или IP сервера, если порт опубликован).

## 5. API Endpoints (`app.py`)

| Endpoint         | Метод | Описание                                                                 |
| :--------------- | :---- | :----------------------------------------------------------------------- |
| `/`              | GET   | Отображение простого веб-интерфейса (`templates/index.html`)             |
| `/ask`           | POST  | Отправка запроса ассистенту и получение ответа.                          |
| `/reset_session` | POST  | Сброс истории диалога для указанного `user_id`.                          |
| `/health`        | GET   | Проверка состояния API и инициализации ассистента.                      |
| `/logs`          | GET   | Получение последних строк лог-файла API (`api.log`).                     |

### Пример запроса к `/ask`:

```json
{
  "message": "Какие услуги лазерной эпиляции есть в Москва-сити?",
  "user_id": "user_abc123", // Опционально, будет сгенерирован, если отсутствует
  "reset_session": false    // Опционально, по умолчанию false
}
```

### Пример ответа от `/ask`:

```json
{
  "response": "В филиале 'Москва-сити' доступны следующие услуги лазерной эпиляции Soprano Titanium для женщин: Soprano Пальцы для женщин, Soprano Подбородок для женщин, Soprano Верхняя губа для женщин и другие. Хотите узнать цены или кто из специалистов их выполняет?",
  "user_id": "user_abc123"
}
```


## 7. Лицензия

Проект распространяется под MIT License.
